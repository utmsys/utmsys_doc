"use strict";(self.webpackChunkutm_doc=self.webpackChunkutm_doc||[]).push([[4329],{2569:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Algorithm_Development/HPC/8xA55 ARM CPU Perf","title":"8xA55 ARM CPU Perf","description":"When porting drone-related algorithms such as path planning (FastPlanner, EgoPlanner), visual input/output (VINS-Fusion), and lidar input/output (Fast-LIO) to the 8-core A55 ARM CPU, targeted optimization is required based on the ARM architecture\'s characteristics (such as multi-core and NEON SIMD) and the algorithm\'s computationally intensive features (matrix operations, nonlinear optimization, and point cloud processing). The following is a detailed optimization approach, organized according to the logic of algorithm characteristics \u2192 architecture adaptation \u2192 engineering practice:","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/09_Algorithm_Development/08_HPC/8xA55 ARM CPU Perf.md","sourceDirName":"09_Algorithm_Development/08_HPC","slug":"/Algorithm_Development/HPC/8xA55 ARM CPU Perf","permalink":"/en/Algorithm_Development/HPC/8xA55 ARM CPU Perf","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"source":"https://wiki.utmsys.org/Algorithm_Development/HPC/%E6%97%A0%E4%BA%BA%E6%9C%BA%E7%AE%97%E6%B3%95%E7%A7%BB%E6%A4%8D8%20%E6%A0%B8%20A55%20ARM%20CPU%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"},"sidebar":"tutorialSidebar","previous":{"title":"9.8 \u9ad8\u6027\u80fd\u8ba1\u7b97","permalink":"/en/08_HPC"},"next":{"title":"ARM Perf","permalink":"/en/Algorithm_Development/HPC/ARM Perf"}}');var a=i(4848),o=i(8453);const r={source:"https://wiki.utmsys.org/Algorithm_Development/HPC/%E6%97%A0%E4%BA%BA%E6%9C%BA%E7%AE%97%E6%B3%95%E7%A7%BB%E6%A4%8D8%20%E6%A0%B8%20A55%20ARM%20CPU%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"},s=void 0,l={},c=[{value:"1.",id:"1",level:3},{value:"1. Matrix Operations and Nonlinear Optimization (VINS-Fusion, Fast-LIO Core",id:"1-matrix-operations-and-nonlinear-optimization-vins-fusion-fast-lio-core",level:4},{value:"2. Point Cloud and Image Processing (Fast-LIO, VINS-Fusion, Path Planning",id:"2-point-cloud-and-image-processing-fast-lio-vins-fusion-path-planning",level:4},{value:"3. Trajectory Optimization in Path Planning (FastPlanner, EgoPlanner",id:"3-trajectory-optimization-in-path-planning-fastplanner-egoplanner",level:4},{value:"2.",id:"2",level:3},{value:"1. Multi-core scheduling and load balancing (the 8-core A55 core advantage",id:"1-multi-core-scheduling-and-load-balancing-the-8-core-a55-core-advantage",level:4},{value:"2. Memory and cache optimization (the A55 cache is small, and access latency needs to be reduced",id:"2-memory-and-cache-optimization-the-a55-cache-is-small-and-access-latency-needs-to-be-reduced",level:4},{value:"3. Engineering Practice and Tool Chain",id:"3-engineering-practice-and-tool-chain",level:3},{value:"1. Compilation toolchain",id:"1-compilation-toolchain",level:4},{value:"2. Performance Analysis and Bottleneck",id:"2-performance-analysis-and-bottleneck",level:4},{value:"4. Algorithm-specific adaptation",id:"4-algorithm-specific-adaptation",level:3},{value:"Conclusion",id:"conclusion",level:3}];function d(e){const n={br:"br",code:"code",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["When porting drone-related algorithms such as path planning (FastPlanner, EgoPlanner), visual input/output (VINS-Fusion), and lidar input/output (Fast-LIO) to the 8-core A55 ARM CPU, targeted optimization is required based on the ARM architecture's characteristics (such as multi-core and NEON SIMD) and the algorithm's computationally intensive features (matrix operations, nonlinear optimization, and point cloud processing). The following is a detailed optimization approach, organized according to the logic of ",(0,a.jsx)(n.strong,{children:"algorithm characteristics \u2192 architecture adaptation \u2192 engineering practice"}),":"]}),"\n",(0,a.jsx)(n.h3,{id:"1",children:"1."}),"\n",(0,a.jsx)(n.h4,{id:"1-matrix-operations-and-nonlinear-optimization-vins-fusion-fast-lio-core",children:"1. Matrix Operations and Nonlinear Optimization (VINS-Fusion, Fast-LIO Core"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Replace the underlying linear algebra library"}),(0,a.jsx)(n.br,{}),"\n",". UAV algorithms that rely heavily on operations such as matrix multiplication, inversion, and SVD decomposition (such as VINS's IMU pre-integration and Fast-LIO's state estimation) need to be replaced with ARM-optimized linear algebra libraries:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Replace the default Eigen implementation with ",(0,a.jsx)(n.strong,{children:"Arm Performance Libraries (ARMPL)"}),": ARMPL optimizes BLAS and LAPACK interfaces for ARM NEON and multi-core architectures. It can directly replace the Eigen backend ( ",(0,a.jsx)(n.code,{children:"EIGEN_USE_BLAS"})," enabled via macros), speeding up matrix operations by 2-5 times."]}),"\n",(0,a.jsxs)(n.li,{children:["Manual optimization of small-scale matrices: For fixed-size matrices such as 3x3 and 4x4 (such as posture rotation matrices), ",(0,a.jsx)(n.code,{children:"vmlaq_f32"})," hand-write them using NEON intrinsic functions (such as vector multiplication and addition) to avoid Eigen's general code redundancy."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimization Nonlinear Optimizers"}),(0,a.jsx)(n.br,{}),"\n","VINS-Fusion and Fast-LIO both use Ceres Solver or g2o for nonlinear optimization, which can:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Enable Ceres' ",(0,a.jsx)(n.strong,{children:"NEON acceleration option"}),": Added when compiling Ceres ",(0,a.jsx)(n.code,{children:"-DCERES_USE_NEON=ON"}),", automatically using NEON instructions to accelerate residual calculations."]}),"\n",(0,a.jsx)(n.li,{children:"Reduce the number of iterations and dimensions: Simplify the state variables according to the UAV scenario (for example, fix some external parameters and only optimize the position and velocity), or lower the convergence threshold (within the accuracy range)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-point-cloud-and-image-processing-fast-lio-vins-fusion-path-planning",children:"2. Point Cloud and Image Processing (Fast-LIO, VINS-Fusion, Path Planning"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Point Cloud Filtering and Registration Acceleration (Fast-LIO)"}),(0,a.jsx)(n.br,{}),"\n","The core of Fast-LIO is the real-time registration of LiDAR point clouds to maps (such as IKFOM filtering), which can:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Downsampling and voxel filtering: Reduce the amount of computation by reducing the number of point clouds (e.g., from 100,000 points/frame to 20,000 points/frame), and use NEON to accelerate the insertion and query of the voxel hash table (changing point coordinate comparison and distance calculation to vector operations)."}),"\n",(0,a.jsxs)(n.li,{children:["Parallel point cloud preprocessing: split the point cloud dedistortion, coordinate transformation and other steps by scan line or area, and distribute them to different cores of the 8-core A55 (using OpenMP ",(0,a.jsx)(n.code,{children:"#pragma omp parallel for"}),"), taking advantage of multi-core parallelism."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Visual Feature Extraction and Matching (VINS-Fusion)"}),(0,a.jsx)(n.br,{}),"\n","VINS relies on the extraction and matching of image features (such as ORB features) to:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Replace ORB-SLAM's feature extraction with a NEON-optimized version: Use ",(0,a.jsx)(n.code,{children:"libORB_SLAM2_NEON"})," branching, or use the ARM-optimized version of OpenCV (with the NEON-enabled module ",(0,a.jsx)(n.code,{children:"opencv_contrib"})," in it ",(0,a.jsx)(n.code,{children:"xfeatures2d"}),") to accelerate FAST corner detection and BRIEF descriptor calculations."]}),"\n",(0,a.jsxs)(n.li,{children:["Reduce image resolution: While ensuring positioning accuracy, reducing the input image from 720p to 480p (such as ",(0,a.jsx)(n.code,{children:"config.yaml"})," the modification in VINS ",(0,a.jsx)(n.code,{children:"image_width"}),") can reduce feature extraction time by more than 50%."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"3-trajectory-optimization-in-path-planning-fastplanner-egoplanner",children:"3. Trajectory Optimization in Path Planning (FastPlanner, EgoPlanner"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Simplified trajectory parameterization and constraint calculation"}),(0,a.jsx)(n.br,{}),"\n","Path planning algorithms need to solve optimization problems with constraints (such as obstacle avoidance constraints and smoothness constraints) in real time, which can:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Reduce the order of trajectory polynomials: For example, reduce the order of EgoPlanner's B-spline from 5 to 3 to reduce the number of constraint equations."}),"\n",(0,a.jsx)(n.li,{children:"Parallelized collision detection: Distribute the calculation of the distance between the 3D grid or obstacle to multiple cores, and use NEON to accelerate the distance vector operation from point to line segment/plane (such as calculating the distance between multiple points and obstacles at the same time)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2",children:"2."}),"\n",(0,a.jsx)(n.h4,{id:"1-multi-core-scheduling-and-load-balancing-the-8-core-a55-core-advantage",children:"1. Multi-core scheduling and load balancing (the 8-core A55 core advantage"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:'The "multi-module pipeline" feature of the task-level parallel splitting'}),(0,a.jsx)(n.br,{}),"\n","drone algorithm is suitable for multi-core allocation, for example:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Sensor data preprocessing (IMU filtering, image distortion correction) \u2192 Core 1-2"}),"\n",(0,a.jsx)(n.li,{children:"State Estimation (front end of VINS/LIO) \u2192 Cores 3-4"}),"\n",(0,a.jsx)(n.li,{children:"Path planning (FastPlanner backend optimization) \u2192 Core 5-6"}),"\n",(0,a.jsxs)(n.li,{children:["Auxiliary tasks such as logging and communication \u2192 Core 7-8",(0,a.jsx)(n.br,{}),"\n","implementation: Use C++11 ",(0,a.jsx)(n.code,{children:"std::thread"})," or ROS ",(0,a.jsx)(n.code,{children:"MultiThreadedSpinner"})," to allocate threads and ",(0,a.jsx)(n.code,{children:"pthread_setaffinity_np"})," bind cores to avoid frequent thread switching."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Data-level parallelism (taking full advantage of NEON SIMD)"}),(0,a.jsx)(n.br,{}),"\n","The A55's NEON unit supports 128-bit vector operations (such as processing 4 float32 data at the same time), which must be explicitly used in the code:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Point cloud/image data is aligned by vector: the point cloud array (x, y, z, i) is adjusted to 16-byte alignment ( ",(0,a.jsx)(n.code,{children:"__attribute__((aligned(16)))"}),") to ensure that NEON instructions can be loaded continuously."]}),"\n",(0,a.jsxs)(n.li,{children:["Loop vectorization: rewrite scalar operations (such as ",(0,a.jsx)(n.code,{children:"sum += x[i] * y[i]"}),") in for loops into NEON vector operations, for example:\ncpp","\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"float32x4_t sum_vec = vdupq_n_f32(0.0f);\nfor (int i=0; i<N; i+=4) {\n    float32x4_t x_vec = vld1q_f32(&x[i]);\n    float32x4_t y_vec = vld1q_f32(&y[i]);\n    sum_vec = vmlaq_f32(sum_vec, x_vec, y_vec); // 4\u5143\u7d20\u540c\u65f6\u4e58\u52a0\n}\nfloat sum = vaddvq_f32(sum_vec); // \u5411\u91cf\u6c42\u548c\u4e3a\u6807\u91cf\n"})}),"\n"]}),"\n"]}),"\n","Tool assistance: Use ",(0,a.jsx)(n.code,{children:"armclang"})," automatic ",(0,a.jsx)(n.code,{children:"-ftree-vectorize"})," vectorization, ",(0,a.jsx)(n.code,{children:"-fopt-info-vec"})," check the vectorization effect, and repair loops that are not vectorized (such as eliminating branches and fixing the number of loops)."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-memory-and-cache-optimization-the-a55-cache-is-small-and-access-latency-needs-to-be-reduced",children:"2. Memory and cache optimization (the A55 cache is small, and access latency needs to be reduced"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduce cache misses."}),(0,a.jsx)(n.br,{}),"\n","The A55's L2 cache is typically 1-2MB (shared by 8 cores), so the data access pattern needs to be optimized:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:['Data is stored in a "row-first" manner: The ARM architecture is friendly to continuous memory access. The matrix is converted from column-first (Eigen default) to row-first (through ',(0,a.jsx)(n.code,{children:"EIGEN_DEFAULT_TO_ROW_MAJOR"})," macros) to improve cache utilization."]}),"\n",(0,a.jsxs)(n.li,{children:["Prefetch data into cache: For large arrays (such as point clouds and image pixels), use ",(0,a.jsx)(n.code,{children:"__builtin_prefetch"})," instructions to load subsequent data in advance (such as ",(0,a.jsx)(n.code,{children:"__builtin_prefetch(&x[i+32])"}),"), masking memory access latency."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduce memory usage."}),(0,a.jsx)(n.br,{}),"\n","The RAM of the 8-core A55 is usually 4-8GB. It is necessary to avoid memory overflow:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Replacement ",(0,a.jsx)(n.code,{children:"float"}),": ",(0,a.jsx)(n.code,{children:"double"})," In most scenarios of drone algorithms (such as IMU integration and feature matching), float (32-bit) is accurate enough, which can reduce memory usage and computational complexity by 50% (NEON is more efficient in float optimization)."]}),"\n",(0,a.jsx)(n.li,{children:"Dynamically release temporary variables: For example, Fast-LIO's point cloud map is stored using a sliding window (only the latest 10 frames are retained) to avoid unlimited accumulation."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-engineering-practice-and-tool-chain",children:"3. Engineering Practice and Tool Chain"}),"\n",(0,a.jsx)(n.h4,{id:"1-compilation-toolchain",children:"1. Compilation toolchain"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use the ARM-specific compiler"}),(0,a.jsx)(n.br,{}),"\n","to replace GCC with ",(0,a.jsx)(n.code,{children:"armclang"})," or ",(0,a.jsx)(n.code,{children:"aarch64-linux-gnu-gcc"})," (with ARM optimization), the compilation option example:\nbash","\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"-march=armv8.2-a+neon -mtune=cortex-a55  # \u9488\u5bf9A55\u67b6\u6784\u4f18\u5316\n-O3 -ffast-math -funsafe-math-optimizations  # \u542f\u7528\u6fc0\u8fdb\u6570\u5b66\u4f18\u5316\uff08\u7cbe\u5ea6\u635f\u5931\u53ef\u63a5\u53d7\u65f6\uff09\n-flto -fvectorize  # \u94fe\u63a5\u65f6\u4f18\u5316\u4e0e\u81ea\u52a8\u5411\u91cf\u5316\n"})}),"\n","Note: ",(0,a.jsx)(n.code,{children:"-ffast-math"})," This may affect numerical stability and should be used with caution in modules that are sensitive to accuracy, such as VINS/LIO (it can be enabled separately for the path planning module)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Prune dependent libraries"}),(0,a.jsx)(n.br,{}),"\n","to remove unused modules in the algorithm (for example, the ROS visualization part of VINS-Fusion can be disabled on the edge, retaining only the core calculations), and use ",(0,a.jsx)(n.code,{children:"strip"})," tools to streamline binary files to reduce loading time."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-performance-analysis-and-bottleneck",children:"2. Performance Analysis and Bottleneck"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Toolchain monitoring"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"perf"})," CPU hotspot analysis: ",(0,a.jsx)(n.code,{children:"perf record -g ./algorithm"})," record function call time and locate the modules with the highest time consumption (such as feature matching of VINS and IKFOM update of Fast-LIO)."]}),"\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"neon-objdump"})," assembly view to confirm whether key functions generate NEON instructions (if they exist ",(0,a.jsx)(n.code,{children:"vld1q_f32"}),", ",(0,a.jsx)(n.code,{children:"vmlaq_f32"})," etc.). Unvectorized code needs to be manually optimized."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Real-time optimization"}),(0,a.jsx)(n.br,{}),"\n","of drone control requires millisecond-level response, which can:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"chrt"})," thread priority setting: Set the state estimation and path planning threads to real-time priority ( ",(0,a.jsx)(n.code,{children:"chrt -f 90 ./algorithm"}),") to avoid being interrupted by system processes."]}),"\n",(0,a.jsxs)(n.li,{children:["Disable CPU throttling: By ",(0,a.jsx)(n.code,{children:"cpufreq-set -g performance"})," fixing the A55 at the highest frequency (1.5GHz), it avoids performance fluctuations caused by power-saving strategies."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"4-algorithm-specific-adaptation",children:"4. Algorithm-specific adaptation"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Algorithm Type"}),(0,a.jsx)(n.th,{children:"Core optimization points"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"WINES-Fusion"}),(0,a.jsx)(n.td,{children:"Use NEON to accelerate ORB feature extraction, ARMPL to optimize IMU pre-integration matrix, float state, multi-core split image and IMU processing"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Fast-LIO"}),(0,a.jsx)(n.td,{children:"Point cloud downsampling + NEON filtering, reduced IKFOM iterations, sliding window map, multi-core parallel registration calculation"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"FastPlanner"}),(0,a.jsx)(n.td,{children:"Reduce the polynomial order of trajectories, parallelize collision detection, and use NEON to accelerate distance calculations"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"EgoPlanner"}),(0,a.jsx)(n.td,{children:"Simplify obstacle avoidance constraints, compress and store raster maps with bitmask, and perform multi-core split path search and optimization."})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(n.p,{children:["The advantage of the 8-core A55 lies in multi-core parallelism and NEON vector operations. The core of the optimization is ",(0,a.jsx)(n.strong,{children:'to "break down computationally intensive tasks into parallel vector operations"'}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Prioritize replacing underlying libraries (ARMPL and NEON-accelerated feature libraries) to achieve a 2-3x performance improvement at minimal cost."}),"\n",(0,a.jsx)(n.li,{children:"Secondly, through multi-core splitting and NEON manual optimization of key modules (such as point cloud registration and matrix operations), the performance is improved by another 1-2 times;"}),"\n",(0,a.jsx)(n.li,{children:"Finally, through compilation optimization and real-time configuration, we ensure that the algorithm completes a single iteration within 100-500ms (meeting the drone control frequency requirements)."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'Note: Optimization requires a balance between "performance - accuracy - power consumption" (for example, float conversion may reduce positioning accuracy, and experiments are needed to verify whether the error is within an acceptable range).'})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var t=i(6540);const a={},o=t.createContext(a);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);