"use strict";(self.webpackChunkutm_doc=self.webpackChunkutm_doc||[]).push([[3661],{4514:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Concepts/PX4","title":"PX4","description":"of PX4 flight control architecture","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/11_Concepts/PX4.md","sourceDirName":"11_Concepts","slug":"/Concepts/PX4","permalink":"/en/Concepts/PX4","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"source":"https://wiki.utmsys.org/Concepts/PX4"},"sidebar":"tutorialSidebar","previous":{"title":"Micro XRCE-DDS ","permalink":"/en/Concepts/Micro XRCE-DDS"},"next":{"title":"12. \u5e38\u89c1\u95ee\u9898","permalink":"/en/12_FAQ"}}');var o=i(4848),s=i(8453);const r={source:"https://wiki.utmsys.org/Concepts/PX4"},a=void 0,l={},d=[{value:"of PX4 flight control architecture",id:"of-px4-flight-control-architecture",level:2},{value:"1.",id:"1",level:3},{value:"2.",id:"2",level:3},{value:"1. Hardware Abstraction Layer (HAL",id:"1-hardware-abstraction-layer-hal",level:4},{value:"2.",id:"2-1",level:4},{value:"(1) Real-time operating system (RTOS",id:"1-real-time-operating-system-rtos",level:5},{value:"(2) Data Distribution and Communication (uORB",id:"2-data-distribution-and-communication-uorb",level:5},{value:"(3) Control algorithm",id:"3-control-algorithm",level:5},{value:"(4) Hardware interface and driver",id:"4-hardware-interface-and-driver",level:5},{value:"3.",id:"3",level:4},{value:"4. Peripheral tools and",id:"4-peripheral-tools-and",level:4},{value:"3. Data Flow and Control",id:"3-data-flow-and-control",level:3},{value:"1. Sensor data processing",id:"1-sensor-data-processing",level:4},{value:"2. Control loop (taking attitude control as an example",id:"2-control-loop-taking-attitude-control-as-an-example",level:4},{value:"3. Task and Communication",id:"3-task-and-communication",level:4},{value:"4. Architecture Advantages and Design",id:"4-architecture-advantages-and-design",level:3},{value:"5. Typical Application",id:"5-typical-application",level:3},{value:"6. Development and Extension",id:"6-development-and-extension",level:3},{value:"Conclusion",id:"conclusion",level:3},{value:"The differences between Pixhawk, FMU, PX4, and FC",id:"the-differences-between-pixhawk-fmu-px4-and-fc",level:2},{value:"1. FC (Flight Controller",id:"1-fc-flight-controller",level:3},{value:"2. Pixhawk",id:"2-pixhawk",level:3},{value:"3. FMU (Flight Management Unit",id:"3-fmu-flight-management-unit",level:3},{value:"4. PX4",id:"4-px4",level:3},{value:"Summary:",id:"summary",level:3},{value:"Introduction to Offboard Mode and Onboard Mode in PX4",id:"introduction-to-offboard-mode-and-onboard-mode-in-px4",level:2},{value:"1. Offboard mode (external control mode",id:"1-offboard-mode-external-control-mode",level:3},{value:"Key Features",id:"key-features",level:4},{value:"2. Onboard mode (autonomous mode, such as Auto/Mission",id:"2-onboard-mode-autonomous-mode-such-as-automission",level:3},{value:"Key Features",id:"key-features-1",level:4},{value:"Core Difference Comparison",id:"core-difference-comparison",level:3},{value:"Conclusion",id:"conclusion-1",level:3},{value:"Detailed explanation of PX4 flight modes",id:"detailed-explanation-of-px4-flight-modes",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"of-px4-flight-control-architecture",children:"of PX4 flight control architecture"}),"\n",(0,o.jsx)(n.p,{children:"PX4 (Pixhawk Autopilot) is an open-source drone flight control system widely used in multirotor, fixed-wing, and vertical take-off and landing (VTOL) drone platforms. Its architecture is designed based on modularity, real-time performance, and scalability, supporting a wide range of application scenarios from consumer to industrial applications. The following provides a detailed analysis of its architecture layering, core components, and data flow:"}),"\n",(0,o.jsx)(n.h3,{id:"1",children:"1."}),"\n",(0,o.jsxs)(n.p,{children:["PX4 adopts ",(0,o.jsx)(n.strong,{children:"a layered architecture design"}),", dividing system functions into different levels. Each layer interacts through standardized interfaces to ensure module decoupling and reusability. The core architecture is divided into:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Hardware Abstraction Layer (HAL)"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Middleware"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Applications"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Peripheral tools and interfaces"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"2",children:"2."}),"\n",(0,o.jsx)(n.h4,{id:"1-hardware-abstraction-layer-hal",children:"1. Hardware Abstraction Layer (HAL"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Function"}),": Shields underlying hardware differences, provides a unified interface for the upper layer, and supports different hardware platforms (such as Pixhawk series, Holybro Kakute, etc.)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Key modules"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor driver"}),": supports inertial measurement units (IMUs) such as gyroscopes, accelerometers, magnetometers, barometers, as well as GPS, vision sensors, etc."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Actuator drive"}),": controls output devices such as motors, servos, and electronic speed controllers (ESCs), and supports communication protocols such as PWM and DShot."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Communication interface"}),": abstract interface of hardware communication protocols such as UART, I2C, SPI, and CAN."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Power management"}),": battery voltage monitoring, power status management."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"2-1",children:"2."}),"\n",(0,o.jsx)(n.p,{children:"The middleware layer is the core of the PX4 architecture, responsible for real-time task scheduling, data processing, and inter-module communication. It includes the following key components:"}),"\n",(0,o.jsx)(n.h5,{id:"1-real-time-operating-system-rtos",children:"(1) Real-time operating system (RTOS"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Based on ",(0,o.jsx)(n.strong,{children:"NuttX RTOS"})," (or Zephyr RTOS), it provides real-time support such as task scheduling, memory management, and interrupt handling."]}),"\n",(0,o.jsx)(n.li,{children:"Supports multi-threaded parallel processing (such as sensor reading, control algorithm, and communication task separation) to ensure real-time response of high-priority tasks (such as posture control)."}),"\n"]}),"\n",(0,o.jsx)(n.h5,{id:"2-data-distribution-and-communication-uorb",children:"(2) Data Distribution and Communication (uORB"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"uORB (Micro Object Request Broker)"}),": PX4's self-developed lightweight message bus for sharing data between modules."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Features"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Publish/Subscribe model: Modules can publish data (such as sensor readings) or subscribe to data (such as control instructions), decoupling dependencies between modules."}),"\n",(0,o.jsx)(n.li,{children:"Real-time guarantee: Message queue priority management ensures that critical data (such as posture information) is transmitted first."}),"\n",(0,o.jsxs)(n.li,{children:["Typical message examples: ",(0,o.jsx)(n.code,{children:"sensor_combined"})," (sensor fusion data), ",(0,o.jsx)(n.code,{children:"vehicle_attitude"})," (aircraft attitude), ",(0,o.jsx)(n.code,{children:"actuator_controls"})," (actuator control instructions)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h5,{id:"3-control-algorithm",children:"(3) Control algorithm"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Attitude Control Module"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Based on PID, complementary filtering and other algorithms, it processes IMU data, calculates the aircraft attitude (roll, pitch, yaw), and outputs motor/servo control variables."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Position & Navigation"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Integrate GPS, visual positioning (such as optical flow), and barometer data to achieve functions such as fixed-point hovering and trajectory tracking."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Mission & Path Planning"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Supports receiving mission instructions (such as waypoint flight) through the MAVLink protocol, or locally executing preset mission scripts (.mission files)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h5,{id:"4-hardware-interface-and-driver",children:"(4) Hardware interface and driver"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Encapsulates the underlying hardware drivers and provides standardized interfaces to the upper layers (such as ",(0,o.jsx)(n.code,{children:"device drivers"})," modules managing sensor devices)."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"3",children:"3."}),"\n",(0,o.jsx)(n.p,{children:"The application layer contains functional modules and command-line tools that users can directly call to implement specific flight modes and tasks:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Airplane Mode"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Manual mode (Manual), Stabilized mode (Stabilized), Position mode (Position), Auto mode (Auto, waypoint flight), Return to Launch (RTL) mode, etc."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Useful tools"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"commander"}),": Receive and execute flight instructions (such as takeoff and landing)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"mavlink"}),": Handles the MAVLink communication protocol and interacts with ground stations such as QGroundControl."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"px4ctl"}),": System configuration and control commands (such as parameter adjustment and log management)."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Extended application"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Supports custom application development (such as visual obstacle avoidance and agricultural spraying control) and is integrated into the system through CMake compilation."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"4-peripheral-tools-and",children:"4. Peripheral tools and"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Ground Station Interface"}),": Communicates with ground station software such as QGroundControl and Mission Planner via the MAVLink protocol to enable parameter configuration, real-time monitoring, and mission planning."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Development toolchain"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A cross-compilation tool based on GCC that supports development on Linux, Windows, and macOS."}),"\n",(0,o.jsx)(n.li,{children:"Simulation environment: Software-in-the-loop (SIL) and hardware-in-the-loop (HIL) simulation tests are implemented through tools such as Gazebo and JSBSim."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Communication protocols"}),": Supports MAVLink, ROS/ROS 2, UDP/TCP and other protocols, facilitating integration with other systems (such as robot operating systems and cloud platforms)."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"3-data-flow-and-control",children:"3. Data Flow and Control"}),"\n",(0,o.jsx)(n.h4,{id:"1-sensor-data-processing",children:"1. Sensor data processing"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Data acquisition"}),": The HAL layer drives the reading of raw sensor data (such as angular velocity and acceleration of IMU)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Preprocessing"}),": Remove noise and calibrate sensor bias through filtering algorithms (such as complementary filtering and Kalman filtering)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Data publishing"}),": Published to the message bus via uORB for the attitude control module to subscribe."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"2-control-loop-taking-attitude-control-as-an-example",children:"2. Control loop (taking attitude control as an example"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Outer loop (position/velocity control)"}),": Calculates the desired attitude (angle) based on the target position (such as a GPS waypoint)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Inner loop (posture control)"}),": Compare the current posture with the desired posture and generate the motor control quantity through the PID algorithm."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Output execution"}),": The control quantity is sent to the ESC/servo through the HAL layer to adjust the aircraft attitude."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"3-task-and-communication",children:"3. Task and Communication"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:['The ground station sends mission instructions (such as "go to coordinates (10,20,30)") through MAVLink. After ',(0,o.jsx)(n.code,{children:"mavlink"})," being parsed by the module, ",(0,o.jsx)(n.code,{children:"commander"})," it is converted into flight control instructions and executed through the control loop."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"4-architecture-advantages-and-design",children:"4. Architecture Advantages and Design"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Modular design"}),": Each functional module is independently developed and tested, facilitating maintenance and expansion (such as adding new sensors or flight modes)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Real-time guarantee"}),": Based on RTOS and uORB message priority mechanism, it ensures the real-time response of the control loop (usually 100-1000Hz)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cross-platform compatibility"}),": Through HAL layer abstraction, it supports multiple hardware platforms (such as Pixhawk 2, FMUv5) and RTOS (NuttX/Zephyr)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Open source ecosystem"}),": Relying on the PX4 open source community, it supports global developers to contribute code and integrates advanced algorithms (such as visual SLAM and autonomous obstacle avoidance)."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"5-typical-application",children:"5. Typical Application"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Consumer drones"}),": such as DJI open source platform and drone control."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Industrial applications"}),": agricultural plant protection, logistics distribution, power inspection, and aerial photography."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Research and education"}),": UAV research in universities and autonomous driving algorithm verification (such as MIT's AeroAstro Lab project)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Special scenarios"}),": military reconnaissance, post-disaster rescue, geological exploration and other fields with high reliability requirements."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"6-development-and-extension",children:"6. Development and Extension"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Source code structure"}),": PX4 source code is organized based on CMake, and the directory structure is clear (such ",(0,o.jsx)(n.code,{children:"src/lib"})," as library files and ",(0,o.jsx)(n.code,{children:"src/modules"})," functional modules)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Custom development"}),": Implement specific functionality by creating new modules (such as ",(0,o.jsx)(n.code,{children:"src/modules/my_application"}),") and interact with other modules using the uORB interface."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Simulation Testing"}),": Use Gazebo to simulate the aircraft and environment, allowing you to verify algorithms without hardware (e.g., ",(0,o.jsx)(n.code,{children:"make px4_sitl gazebo"})," launching simulation)."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"The PX4 flight control architecture achieves efficient and flexible drone control through a layered design, modular components, and real-time communication mechanisms. From the underlying hardware drivers to the upper-layer application functions, each layer works together through standardized interfaces, meeting the reliability requirements of industrial drones while providing open expansion space for developers. Whether rapidly developing consumer drones or enabling autonomous control in complex scenarios, the PX4 architecture demonstrates strong adaptability and scalability."}),"\n",(0,o.jsx)(n.h2,{id:"the-differences-between-pixhawk-fmu-px4-and-fc",children:"The differences between Pixhawk, FMU, PX4, and FC"}),"\n",(0,o.jsx)(n.p,{children:"In the field of drone flight control, Pixhawk, FMU, PX4, and FC are closely related but distinct concepts, corresponding to hardware, core modules, software systems, and functional categories, respectively. The following is a detailed explanation of the specific differences and connections:"}),"\n",(0,o.jsx)(n.h3,{id:"1-fc-flight-controller",children:"1. FC (Flight Controller"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:'Definition: FC is a general term for "flight control," which refers to'})," ",(0,o.jsx)(n.strong,{children:"the hardware equipment"}),' responsible for core functions such as drone attitude control, navigation, and mission execution . It is the "brain" of the drone.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Function"}),": Obtain the drone status through sensors (gyroscope, accelerometer, GPS, etc.), calculate control instructions, drive motors or servos to adjust flight attitude, and process ground station instructions and perform autonomous tasks."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Scope"}),": All drone flight control hardware can be called FC. For example, Pixhawk, APM (ArduPilot Mega), DJI's N3/M6, etc. are all specific FC products."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"2-pixhawk",children:"2. Pixhawk"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Definition"}),": Pixhawk is ",(0,o.jsx)(n.strong,{children:"a specific series of flight control hardware"}),", developed by the open source drone community (such as the PX4 project). It was originally based on the design of 3DRobotics and has now become the benchmark for open source flight control."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Features"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Open source hardware: Design drawings and specifications are made public to support secondary development."}),"\n",(0,o.jsx)(n.li,{children:"Strong compatibility: compatible with various drone types (multi-rotor, fixed-wing, helicopter, etc.)."}),"\n",(0,o.jsx)(n.li,{children:"There are many iterative versions: such as Pixhawk 1 (FMUv2), Pixhawk 2.1 (FMUv3), Pixhawk 4 (FMUv5), etc. The performance improves with each version (computing power, sensor accuracy, etc.)."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Relationship with FC"}),": Pixhawk is a specific implementation of FC and one of the most well-known open source FC products."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"3-fmu-flight-management-unit",children:"3. FMU (Flight Management Unit"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Definition: The FMU is"})," ",(0,o.jsx)(n.strong,{children:"the core computing module"}),' in the Pixhawk hardware , equivalent to the "main chip" of the flight control system. It is responsible for running flight control algorithms, processing sensor data, and executing control logic.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Composition"}),": Usually includes a microprocessor (such as the STM32 series), memory, power management circuits, etc., and is the core component of Pixhawk hardware."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Version correspondence"}),": Different Pixhawk models correspond to different versions of FMU, for example:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Pixhawk 1 with FMUv2"}),"\n",(0,o.jsx)(n.li,{children:"Pixhawk 4 with FMUv5"}),"\n",(0,o.jsx)(n.li,{children:"Version upgrades usually mean stronger computing power, more interfaces, and better stability."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Relationship with Pixhawk"}),": FMU is part of Pixhawk hardware and is the core unit for implementing flight control functions."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"4-px4",children:"4. PX4"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Definition"}),": PX4 is ",(0,o.jsx)(n.strong,{children:"an open source flight control software system"})," that runs on flight control hardware (such as Pixhawk) and is responsible for implementing the autonomous flight logic (attitude control, path planning, task scheduling, etc.) of the drone."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Function"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Provides underlying control algorithms (such as PID control and LQR control)."}),"\n",(0,o.jsx)(n.li,{children:"Supports a variety of sensors and peripherals (GPS, barometer, obstacle avoidance radar, etc.)."}),"\n",(0,o.jsx)(n.li,{children:"Compatible with ground station software (such as QGroundControl) and supports manual/automatic flight mode switching."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Relationship with hardware"}),": PX4 is software that needs to run on specific hardware. ",(0,o.jsx)(n.strong,{children:"The most typical compatible hardware is Pixhawk"}),", but it can also be ported to other FCs (such as DJI N3 partially supports PX4)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Difference from ArduPilot"}),": PX4 and ArduPilot are two mainstream open source flight control software. PX4 focuses more on modular design and real-time performance, while ArduPilot is known for its rich features and ease of use. Both can run on Pixhawk."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"summary",children:"Summary:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"concept"}),(0,o.jsx)(n.th,{children:"type"}),(0,o.jsx)(n.th,{children:"Core role"}),(0,o.jsx)(n.th,{children:"Examples/Correspondence"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"FC"}),(0,o.jsx)(n.td,{children:"Functional Category"}),(0,o.jsx)(n.td,{children:'The "brain" of the drone (a general term for hardware)'}),(0,o.jsx)(n.td,{children:"Pixhawk, DJI N3, etc. are all FC"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Pixhawk"}),(0,o.jsx)(n.td,{children:"Hardware products"}),(0,o.jsx)(n.td,{children:"Specific models of open source flight controllers"}),(0,o.jsx)(n.td,{children:"A type of FC equipped with FMU module"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"FMU"}),(0,o.jsx)(n.td,{children:"Hardware Module"}),(0,o.jsx)(n.td,{children:"Pixhawk's core computing unit"}),(0,o.jsx)(n.td,{children:"Part of Pixhawk (such as FMUv5)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"PX4"}),(0,o.jsx)(n.td,{children:"Software System"}),(0,o.jsx)(n.td,{children:"Flight control algorithm running on FC"}),(0,o.jsx)(n.td,{children:"Most suitable for Pixhawk, can also be used for other FC"})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["Simply put: ",(0,o.jsx)(n.strong,{children:"FC is a general term for flight control, Pixhawk is an open source FC hardware, FMU is the core module of Pixhawk, and PX4 is the control software running on FC such as Pixhawk"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-offboard-mode-and-onboard-mode-in-px4",children:"Introduction to Offboard Mode and Onboard Mode in PX4"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Offboard mode"})," and ",(0,o.jsx)(n.strong,{children:"Onboard mode"}),' in PX4 (usually referring to autonomous modes such as Auto and Mission; note that "Onboard" is not a standard mode name officially defined by PX4, but rather a relative term to Offboard) are two different control methods. The core difference lies in ',(0,o.jsx)(n.strong,{children:"the source of control commands"})," and ",(0,o.jsx)(n.strong,{children:"the degree of autonomy"}),", as follows:"]}),"\n",(0,o.jsx)(n.h3,{id:"1-offboard-mode-external-control-mode",children:"1. Offboard mode (external control mode"}),"\n",(0,o.jsxs)(n.p,{children:["Offboard mode is a PX4 mode specifically designed for ",(0,o.jsx)(n.strong,{children:"drones controlled by external devices (such as ground stations, onboard computers, ROS nodes, etc.)"}),". In this mode, the drone's core control commands (such as position, speed, attitude, and throttle) are sent entirely by the external system to the flight controller via a specific protocol. The flight controller is solely responsible for executing these commands and providing basic stability control (such as maintaining a stable attitude)."]}),"\n",(0,o.jsx)(n.h4,{id:"key-features",children:"Key Features"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"External control source"}),": Commands must be sent in real time (usually at a frequency \u2265 2Hz) by an external device (such as an algorithm running on an onboard computer or ground station software) via the Mavlink protocol. Otherwise, the flight control will automatically switch to a safe mode (such as Altitude or Position mode) after a timeout to prevent loss of control."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"High flexibility"}),": Suitable for custom control logic, such as trajectory tracking, obstacle avoidance algorithms, and SLAM navigation in scientific research. Users can generate complex motion commands through programming."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dependence on external systems"}),": External device failure or communication interruption will directly affect the safety of the drone, so redundant design or emergency switching mechanism is usually required."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Typical applications"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Autonomous navigation algorithm testing based on ROS."}),"\n",(0,o.jsx)(n.li,{children:"The ground station manually sends custom track points."}),"\n",(0,o.jsx)(n.li,{children:"The onboard computer uses visual sensors to achieve autonomous obstacle avoidance."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"2-onboard-mode-autonomous-mode-such-as-automission",children:"2. Onboard mode (autonomous mode, such as Auto/Mission"}),"\n",(0,o.jsxs)(n.p,{children:['PX4\'s "Onboard Mode" primarily refers to ',(0,o.jsx)(n.strong,{children:"the flight controller's autonomous decision-making and generation of control commands"}),". The most typical of the official standard modes is ",(0,o.jsx)(n.strong,{children:"Auto"})," (Mission Mode), but other modes include Mission, Hold, and Return. In these modes, control logic and command generation are entirely internal to the flight controller, requiring no external intervention."]}),"\n",(0,o.jsx)(n.h4,{id:"key-features-1",children:"Key Features"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"The control source is internal to the flight controller"}),": The flight controller autonomously generates control commands based on predefined tasks (such as waypoint lists), sensor data (such as GPS, IMU) and built-in algorithms (such as PID controllers), without the need for external input."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Strong autonomy"}),": Without continuous external communication, the flight control can independently complete tasks such as takeoff, waypoint flight, and landing."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Standardized process"}),": Relying on the mature control logic built into the flight controller, users only need to plan the mission (such as setting waypoints, altitude, and speed) through the ground station, without having to write complex control algorithms."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Typical applications"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Automatic inspection according to preset waypoints."}),"\n",(0,o.jsx)(n.li,{children:"Perform repetitive mapping tasks."}),"\n",(0,o.jsx)(n.li,{children:"Automatic return to home in emergency situations (Return mode)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"core-difference-comparison",children:"Core Difference Comparison"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:(0,o.jsx)(n.strong,{children:"Dimensions"})}),(0,o.jsx)(n.th,{children:(0,o.jsx)(n.strong,{children:"Offboard Mode"})}),(0,o.jsx)(n.th,{children:(0,o.jsx)(n.strong,{children:"Onboard mode (such as Auto)"})})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Control command source"})}),(0,o.jsx)(n.td,{children:"External equipment (onboard computer, ground station, etc.)"}),(0,o.jsx)(n.td,{children:"Flight control internals (predefined tasks, built-in algorithms)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Autonomy"})}),(0,o.jsx)(n.td,{children:"Depends on external systems, the flight control only executes instructions"}),(0,o.jsx)(n.td,{children:"Completely autonomous, no external intervention required"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Communication Request"})}),(0,o.jsx)(n.td,{children:"Instructions must be sent in real time (\u22652Hz), otherwise the safety mode will be triggered"}),(0,o.jsx)(n.td,{children:"No need for continuous communication, only configuration during mission planning"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"flexibility"})}),(0,o.jsx)(n.td,{children:"High, supports custom control algorithms"}),(0,o.jsx)(n.td,{children:"Low, relies on the built-in logic of the flight controller, only configurable parameters/waypoints"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Typical uses"})}),(0,o.jsx)(n.td,{children:"Scientific research, custom algorithm testing (such as trajectory tracking, obstacle avoidance)"}),(0,o.jsx)(n.td,{children:"Routine task execution (inspection, surveying, automatic return)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Security Mechanism"})}),(0,o.jsx)(n.td,{children:"Redundant design that relies on external systems"}),(0,o.jsx)(n.td,{children:"Flight controller with built-in safety logic (such as low battery return, fault protection)"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"conclusion-1",children:"Conclusion"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["If you need to ",(0,o.jsx)(n.strong,{children:"control the drone with your own algorithms"})," (such as implementing a specific trajectory or obstacle avoidance logic), select ",(0,o.jsx)(n.strong,{children:"Offboard mode"})," and ensure the real-time and reliability of external commands."]}),"\n",(0,o.jsxs)(n.li,{children:["If you only need the drone ",(0,o.jsx)(n.strong,{children:"to complete tasks autonomously according to a preset process"})," (such as flying according to waypoints), select ",(0,o.jsx)(n.strong,{children:"an autonomous mode such as Auto"}),". The flight control will handle most of the low-level control, which is simpler and more stable."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In actual applications, the two modes can be used in combination (e.g., the Offboard mode performs complex tasks, and the return-to-home function of the Auto mode is switched to when an emergency occurs)."}),"\n",(0,o.jsx)(n.h2,{id:"detailed-explanation-of-px4-flight-modes",children:"Detailed explanation of PX4 flight modes"}),"\n",(0,o.jsx)(n.p,{children:"PX4 has multiple flight modes, which can be divided into manual mode, assisted mode, and automatic mode. The following is a detailed introduction3:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Manual Mode"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Manual mode"}),": The remote controller is the control source, and the stick values are converted to the desired attitude. The user directly controls the aircraft via the remote controller; the flight controller does not control the position, and the position may drift due to wind."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Acro (Stunt Mode)"}),": Suitable for Flying Drones, but should be used with caution by beginners. Remote control stick measurements are converted to desired angular rates. The flight controller controls angular rate but not attitude. This allows the aircraft to perform complex acrobatic maneuvers, making it more difficult to operate."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Assisted Mode"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Altitude Mode"}),": The aircraft maintains a constant altitude when the throttle is neutral, making it suitable for novice pilots. The aircraft maintains a stable altitude but cannot maintain a fixed position. Winds may cause the aircraft to drift horizontally."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Position (Fixed Position Mode)"}),": Shifts the stick values into desired velocities on all three axes. When the stick values are neutral, the aircraft's speed is zero, and the position remains unchanged, allowing it to hover. This mode allows the aircraft to withstand wind and maintain a fixed position, making it a safer choice for beginners."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Automatic mode"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Takeoff"}),": When switching to this mode, the aircraft automatically takes off, flies vertically upward to the set altitude, and then remains in the hover, and does not accept joystick control."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Land (One-key landing)"}),": The aircraft descends vertically at the speed set by the parameters, maintains the idle speed for the set time after landing, and then locks."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Return (One-key return)"}),": The aircraft first flies upward to a certain altitude, then returns to above the HOME point in a straight line or along the original route according to the parameters, and then slowly descends to the ground in landing mode."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Mission Mode"}),": Waypoints must be planned via the ground station and uploaded to the aircraft. Once in Mission Mode, the drone will fly according to the planned waypoints and speeds, controlled by the cascade of the position and attitude control loops."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Offboard mode"}),": The aircraft receives and responds to external control data transmitted via MAVLink, primarily serving as an interface for external control data. It requires auxiliary information for periodic communication and maintenance; otherwise, it will exit this mode."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);