"use strict";(self.webpackChunkutm_doc=self.webpackChunkutm_doc||[]).push([[3439],{3567:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Algorithm_Development/HPC/Arm Performance Libraries","title":"Arm Performance Libraries ","description":"When replacing Eigen\'s backend with the Arm Performance Libraries (APL), which includes optimized linear algebra implementations such as Arm BLAS and LAPACK, the core idea is to have Eigen call the underlying linear algebra functions (such as matrix multiplication and decomposition) provided by APL, which are optimized for the Arm architecture, rather than Eigen\'s own general-purpose implementations. This allows APL to leverage the instruction set (such as NEON) and architectural features optimized for Arm CPUs (such as the A55) to improve computing performance. The following are the specific steps and precautions:","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/09_Algorithm_Development/08_HPC/Arm Performance Libraries.md","sourceDirName":"09_Algorithm_Development/08_HPC","slug":"/Algorithm_Development/HPC/Arm Performance Libraries","permalink":"/en/Algorithm_Development/HPC/Arm Performance Libraries","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Arm Performance Libraries ","source":"https://wiki.utmsys.org/Algorithm_Development/HPC/Arm%20Performance%20Libraries%E6%9B%BF%E4%BB%A3Eigen%E7%9A%84%E5%90%8E%E7%AB%AF"},"sidebar":"tutorialSidebar","previous":{"title":"ARM Perf","permalink":"/en/Algorithm_Development/HPC/ARM Perf"},"next":{"title":"EMLL","permalink":"/en/Algorithm_Development/HPC/EMLL"}}');var t=n(4848),a=n(8453);const l={title:"Arm Performance Libraries ",source:"https://wiki.utmsys.org/Algorithm_Development/HPC/Arm%20Performance%20Libraries%E6%9B%BF%E4%BB%A3Eigen%E7%9A%84%E5%90%8E%E7%AB%AF"},o=void 0,s={},c=[{value:"1. Principle: Eigen&#39;s",id:"1-principle-eigens",level:3},{value:"2. Specific steps: Replace Eigen",id:"2-specific-steps-replace-eigen",level:3},{value:"1. Install the Arm Performance",id:"1-install-the-arm-performance",level:4},{value:"2. Configure Eigen to enable external BLAS/LAPACK",id:"2-configure-eigen-to-enable-external-blaslapack",level:4},{value:"(1) Modify Eigen configuration (or compile macro",id:"1-modify-eigen-configuration-or-compile-macro",level:5},{value:"(2) Linking the APL",id:"2-linking-the-apl",level:5},{value:"3. Verify that",id:"3-verify-that",level:4},{value:"3.",id:"3",level:3},{value:"4. Alternative: Directly call the APL",id:"4-alternative-directly-call-the-apl",level:3}];function d(e){const i={a:"a",br:"br",code:"code",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"When replacing Eigen's backend with the Arm Performance Libraries (APL), which includes optimized linear algebra implementations such as Arm BLAS and LAPACK, the core idea is to have Eigen call the underlying linear algebra functions (such as matrix multiplication and decomposition) provided by APL, which are optimized for the Arm architecture, rather than Eigen's own general-purpose implementations. This allows APL to leverage the instruction set (such as NEON) and architectural features optimized for Arm CPUs (such as the A55) to improve computing performance. The following are the specific steps and precautions:"}),"\n",(0,t.jsx)(i.h3,{id:"1-principle-eigens",children:"1. Principle: Eigen's"}),"\n",(0,t.jsxs)(i.p,{children:["Eigen itself is a header-only library. Its underlying linear algebra operations use its own handwritten implementation by default (partially optimized with NEON instructions), but it also supports calling external optimized BLAS (Basic Linear Algebra Subprograms) and LAPACK (Linear Algebra Package) libraries (such as APL, OpenBLAS, and MKL) through ",(0,t.jsx)(i.strong,{children:"interface adaptation"}),(0,t.jsx)(i.br,{}),"\n",". When Eigen detects external BLAS/LAPACK, it prioritizes calling these libraries' efficient implementations (especially for large matrix operations such as ",(0,t.jsx)(i.code,{children:"gemm"})," matrix multiplication and ",(0,t.jsx)(i.code,{children:"gesvd"})," singular value decomposition), thereby improving performance."]}),"\n",(0,t.jsx)(i.h3,{id:"2-specific-steps-replace-eigen",children:"2. Specific steps: Replace Eigen"}),"\n",(0,t.jsx)(i.h4,{id:"1-install-the-arm-performance",children:"1. Install the Arm Performance"}),"\n",(0,t.jsx)(i.p,{children:"First, you need to install APL on the target Arm platform (such as an A55 architecture edge device)."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Download"}),": Get the APL installation package for Arm 64-bit (aarch64) from the Arm official website (registration required, ",(0,t.jsx)(i.a,{href:"https://developer.arm.com/tools-and-software/server-and-hpc/arm-performance-libraries",children:"Arm developer website"})," )."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Installation"}),": Install according to the official guide. The default path is usually ",(0,t.jsx)(i.code,{children:"/opt/arm/armpl/<\u7248\u672c\u53f7>/"}),", which contains header files ( ",(0,t.jsx)(i.code,{children:"include/"}),") and library files ( ",(0,t.jsx)(i.code,{children:"lib/"}),", such as ",(0,t.jsx)(i.code,{children:"libarmpl_lp64.so"}),", ",(0,t.jsx)(i.code,{children:"lp64"})," corresponding to 64-bit mode)."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"2-configure-eigen-to-enable-external-blaslapack",children:"2. Configure Eigen to enable external BLAS/LAPACK"}),"\n",(0,t.jsx)(i.p,{children:"Eigen controls whether to enable external BLAS/LAPACK through macro definitions. Relevant macros and link options must be specified during compilation."}),"\n",(0,t.jsx)(i.h5,{id:"1-modify-eigen-configuration-or-compile-macro",children:"(1) Modify Eigen configuration (or compile macro"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Define the following macros before including the Eigen header file"})," in your code , or pass them in the compilation command ",(0,t.jsx)(i.code,{children:"-D"}),":"]}),"\n",(0,t.jsx)(i.p,{children:"cpp"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-cpp",children:"// \u542f\u7528 Eigen \u5bf9\u5916\u90e8 BLAS \u7684\u652f\u6301\n#define EIGEN_USE_BLAS\n// \u542f\u7528 Eigen \u5bf9\u5916\u90e8 LAPACK \u7684\u652f\u6301\uff08\u5982\u9700\u77e9\u9635\u5206\u89e3\u7b49\u9ad8\u7ea7\u529f\u80fd\uff09\n#define EIGEN_USE_LAPACK\n"})}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"cblas_*"})," These macros will cause Eigen to prioritize calling external BLAS (such as APL functions) and LAPACK (such as functions) when compiling ",(0,t.jsx)(i.code,{children:"lapack_*"}),"."]}),"\n",(0,t.jsx)(i.h5,{id:"2-linking-the-apl",children:"(2) Linking the APL"}),"\n",(0,t.jsxs)(i.p,{children:["When compiling the code, you need to specify the APL header file path, library path, and link the APL BLAS/LAPACK library.",(0,t.jsx)(i.br,{}),"\n","For ",(0,t.jsx)(i.code,{children:"g++"})," example, the compilation command must include:"]}),"\n",(0,t.jsx)(i.p,{children:"bash"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-bash",children:"# \u5934\u6587\u4ef6\u8def\u5f84\uff08APL \u7684 include \u76ee\u5f55\uff09\n-I/opt/arm/armpl/<\u7248\u672c\u53f7>/include\n# \u5e93\u6587\u4ef6\u8def\u5f84\uff08APL \u7684 lib \u76ee\u5f55\uff09\n-L/opt/arm/armpl/<\u7248\u672c\u53f7>/lib\n# \u94fe\u63a5 APL \u7684 BLAS/LAPACK \u5e93\uff08\u6839\u636e APL \u7248\u672c\u53ef\u80fd\u9700\u8981\u8c03\u6574\u5e93\u540d\uff09\n-larmpl_lp64 -larmpl_lp64_mp  # 64\u4f4d\u6a21\u5f0f\u7684\u5e93\uff0c\u5177\u4f53\u540d\u79f0\u4ee5\u5b89\u88c5\u76ee\u5f55\u4e3a\u51c6\n# \u82e5 APL \u4f9d\u8d56\u5176\u4ed6\u5e93\uff08\u5982 pthread\uff09\uff0c\u9700\u8865\u5145\u94fe\u63a5\n-lpthread -lm\n"})}),"\n",(0,t.jsx)(i.h4,{id:"3-verify-that",children:"3. Verify that"}),"\n",(0,t.jsx)(i.p,{children:"After the replacement, you need to verify whether Eigen actually uses the APL backend to avoid still using Eigen's own implementation:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method 1: Check the compilation log."}),(0,t.jsx)(i.br,{}),"\n","If a prompt similar to the call appears during compilation ",(0,t.jsx)(i.code,{children:"Eigen::blas::gemm"})," (or no error is reported), it means that the macro definition is effective."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method 2: Performance Comparison"}),(0,t.jsx)(i.br,{}),"\n",": Run code containing large matrix operations (such as ",(0,t.jsx)(i.code,{children:"matrixA * matrixB"})," and ",(0,t.jsx)(i.code,{children:"matrix.jacobiSvd()"}),") and compare the time taken before and after the replacement. If APL is correctly adapted, the performance of large matrix operations should be significantly improved (the difference may not be noticeable for small matrices due to call overhead)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Method 3: Tool debugging"}),(0,t.jsx)(i.br,{}),"\n","Use ",(0,t.jsx)(i.code,{children:"ldd"})," the command to check whether the generated executable file is linked with the APL library (for example ",(0,t.jsx)(i.code,{children:"libarmpl_lp64.so"}),"):\nbash","\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-bash",children:"ldd your_executable | grep armpl\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"3",children:"3."}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Applicable Scenarios:"}),(0,t.jsx)(i.br,{}),"\n","APL significantly optimizes ",(0,t.jsx)(i.strong,{children:"large matrix operations"})," (such as matrix multiplication and SVD decomposition with dimensions > 100). However, for small matrices (such as 3x3 matrices in VIO), it may not be as efficient as Eigen's built-in NEON optimization due to high function call overhead. The benefits should be determined based on the matrix size of the actual algorithm (such as sliding window optimization in VINS-Fusion and state estimation in Fast-LIO)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Data type compatibility:"}),(0,t.jsx)(i.br,{}),"\n","Eigen uses column-major storage by default, which is consistent with the BLAS standard and does not require data layout adjustment. However, you must ensure that Eigen's data types (such as ",(0,t.jsx)(i.code,{children:"float"})," / ",(0,t.jsx)(i.code,{children:"double"}),") match the precision of APL compilation ( ",(0,t.jsx)(i.code,{children:"lp64"})," corresponding to 64-bit integer + 32-bit float/64-bit double)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Some functions do not support"}),(0,t.jsx)(i.br,{}),"\n","some advanced features in Eigen (such as sparse matrices and custom operators) and may not call external BLAS/LAPACK. They still need to rely on Eigen's own implementation and require targeted optimization (such as manually calling the APL interface)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"After replacing the backend in combination with other optimizations"}),(0,t.jsx)(i.br,{}),"\n",", performance can be further improved by combining it with other optimizations (such as compiler ",(0,t.jsx)(i.code,{children:"-O3 -march=armv8.2-a+neon"})," options and OpenMP multi-threaded parallelism) (APL itself also supports multi-threading, and ",(0,t.jsx)(i.code,{children:"ARMPL_NUM_THREADS"})," the number of threads can be controlled through environment variables)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Version compatibility:"}),(0,t.jsx)(i.br,{}),"\n","Ensure that the Eigen version (3.3 or later is recommended) supports external BLAS/LAPACK, and that the APL version matches the target Arm architecture (e.g., A55 belongs to Armv8.2-A) to avoid instruction set incompatibilities (e.g., APL is compiled with instructions that A55 does not support)."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"4-alternative-directly-call-the-apl",children:"4. Alternative: Directly call the APL"}),"\n",(0,t.jsxs)(i.p,{children:["If Eigen is not well adapted to APL, you can directly call APL's C interface (such as single-precision matrix multiplication) in key computing modules (such as covariance matrix update in VIO and point cloud registration in LIO) ",(0,t.jsx)(i.code,{children:"cblas_sgemm"})," and skip the Eigen intermediate layer. For example:"]}),"\n",(0,t.jsx)(i.p,{children:"cpp"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-cpp",children:'#include "armpl.h"  // APL \u7684\u5934\u6587\u4ef6\n// \u8ba1\u7b97 C = alpha*A*B + beta*C\uff08A: MxK, B: KxN, C: MxN\uff0c\u5217\u4e3b\u5e8f\uff09\ncblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans,\n            M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n'})}),"\n",(0,t.jsx)(i.p,{children:"Through the above method, Arm architecture edge devices (such as the 8-core A55) can fully utilize APL's hardware optimization to improve operating efficiency in linear algebra-intensive tasks such as path planning, VIO, and LIO algorithms."})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>o});var r=n(6540);const t={},a=r.createContext(t);function l(e){const i=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(a.Provider,{value:i},e.children)}}}]);